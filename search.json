[{"categories":null,"content":"这里是记录生活碎片的地方\n","description":"","tags":null,"title":"这里是记录生活碎片的地方","uri":"/life/recordlife/"},{"categories":null,"content":"Elasticsearch的索引思路:\n 将磁盘里的东西尽量搬进内存，减少磁盘随机读取次数(同时也利用磁盘顺序读特性)，结合各种奇技淫巧的压缩算法，用及其苛刻的态度使用内存。\n 加速检索的设计有：\n对各个field建立倒排索引，建立posting list和term dictionary（加速对field的检索） 基于term dictionary block建立term index（基于公共前缀建立的树形结构），term index会被加载到内存中（FST压缩）。 对于posting list，使用roaring bitmap进行压缩。 对于多field联合查询，采用跳表和按位与的方法对多个posting list进行搜索。 所以，对于使用Elasticsearch进行索引时需要注意:\n不需要索引的字段，一定要明确定义出来，因为默认是自动建索引的 同样的道理，对于String类型的字段，不需要analysis的也需要明确定义出来，因为默认也是会analysis的 选择有规律的ID很重要，随机性太大的ID(比如java的UUID)不利于查询 关于最后一点，可能有多个因素:\n其中一个(也许不是最重要的)因素: 上面看到的压缩算法，都是对Posting list里的大量ID进行压缩的，那如果ID是顺序的，或者是有公共前缀等具有一定规律性的ID，压缩比会比较高；\n另外一个因素: 可能是最影响查询性能的，应该是最后通过Posting list里的ID到磁盘中查找Document信息的那步，因为Elasticsearch是分Segment存储的，根据ID这个大范围的Term定位到Segment的效率直接影响了最后查询的性能，如果ID是有规律的，可以快速跳过不包含该ID的Segment，从而减少不必要的磁盘读次数。\n","description":"","tags":null,"title":"Elasticsearch 学习记录","uri":"/posts/elasticsearch/"},{"categories":null,"content":" xy :revolving_hearts: z Pain is inevitable, suffering is optional.\n","description":"","tags":null,"title":"About me","uri":"/about/"},{"categories":null,"content":"形式是重要的，但是内容更重要。\n很多时候面对deadline的压力，先开始第一步总是解决焦虑的最好方式，你没有办法在一开始就做到完美。\n接受不完美的开始，比起犹豫不决，先快速开始第一步，然后不断地去学习和更新，才是更好的方式。\n毕其功于一役是很好的，可是生活中这样的事情太少，体验不断polish的工作和生活，也不失为一种浪漫。\nBy 张醒言\n","description":"","tags":null,"title":"开始博客的一点小想法","uri":"/posts/first/"}]
